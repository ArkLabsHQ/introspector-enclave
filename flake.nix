{
  description = "Nitro Enclave - reproducible build";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    aws-nitro-util.url = "github:monzo/aws-nitro-util";
  };

  outputs = { self, nixpkgs, flake-utils, aws-nitro-util }:
    flake-utils.lib.eachSystem [ "x86_64-linux" ] (system:
      let
        pkgs = import nixpkgs { inherit system; };
        nitro = aws-nitro-util.lib.${system};

        # Read build config generated by `enclave build` from enclave.yaml.
        # BUILD_CONFIG_PATH is set by the CLI; defaults to /src/build-config.json (Docker).
        # Requires --impure flag (already set by the CLI).
        configPath = let p = builtins.getEnv "BUILD_CONFIG_PATH"; in
          if p != "" then p else "/src/build-config.json";
        buildCfg = builtins.fromJSON (builtins.readFile configPath);
        appCfg = buildCfg.app;

        # Fall back to env vars for backwards compatibility.
        version = buildCfg.version;
        region = buildCfg.region;
        deployment = buildCfg.prefix;

        # Filter source to only include files relevant to the Go build.
        src = pkgs.lib.cleanSourceWith {
          src = ./enclave;
          filter = path: type:
            let
              isGoFile = pkgs.lib.hasSuffix ".go" path;
              isGoMod = builtins.baseNameOf path == "go.mod" || builtins.baseNameOf path == "go.sum";
            in
              type == "directory" || isGoFile || isGoMod;
        };

        # Init binary: decrypts key via KMS, extends PCR16 with pubkey hash,
        # then exec's the upstream app binary.
        enclave-init = pkgs.buildGoModule {
          pname = "enclave-init";
          inherit version src;

          vendorHash = "sha256-rNodO+mGTZv5DY+PAk8tIfhhysfP6IuP3LgWvV4rKKc=";

          subPackages = [ "." ];
          env.CGO_ENABLED = "0";
          ldflags = [
            "-X" "main.Version=${version}"
          ];

          # Deterministic build flags.
          buildFlags = [ "-trimpath" ];
          tags = [ "netgo" ];

          postInstall = ''
            mv $out/bin/introspector-enclave $out/bin/enclave-init
          '';
        };

        # Upstream app binary â€” fetched dynamically from build-config.json.
        upstream-app = pkgs.buildGoModule {
          pname = appCfg.binary_name;
          version = buildCfg.version;

          src = pkgs.fetchFromGitHub {
            owner = appCfg.nix_owner;
            repo = appCfg.nix_repo;
            rev = appCfg.nix_rev;
            hash = appCfg.nix_hash;
          };

          vendorHash = appCfg.nix_vendor_hash;

          subPackages = appCfg.nix_sub_packages;
          env.CGO_ENABLED = "0";
          buildFlags = [ "-trimpath" ];
          tags = [ "netgo" ];
          doCheck = false;

          postInstall = ''
            # Rename whatever was built to the configured binary name.
            for f in $out/bin/*; do
              if [ "$(basename "$f")" != "${appCfg.binary_name}" ]; then
                mv "$f" "$out/bin/${appCfg.binary_name}"
              fi
            done
          '';
        };

        # Nitriding TLS termination daemon.
        nitriding = pkgs.buildGoModule {
          pname = "nitriding-daemon";
          version = "unstable-2024-01-01";

          src = pkgs.fetchFromGitHub {
            owner = "brave";
            repo = "nitriding-daemon";
            rev = "c8cb7248843c82a5d72ff6cdde90f4a4cf68c87f";
            hash = "sha256-0ww8ZcoUh3UgRJyhfEVwmjxk3tZv7exCw0VmftdnM7U=";
          };

          vendorHash = "sha256-B/1tbPfId6qgvaMwPF5w4gFkkkeoI+5k+x0jEvJxQus=";

          env.CGO_ENABLED = "0";
          buildFlags = [ "-trimpath" ];
          doCheck = false;

          postInstall = ''
            mv $out/bin/nitriding-daemon $out/bin/nitriding
          '';
        };

        # Viproxy for IMDS forwarding inside the enclave.
        viproxy = pkgs.buildGoModule {
          pname = "viproxy";
          version = "0.1.2";

          src = pkgs.fetchFromGitHub {
            owner = "brave";
            repo = "viproxy";
            rev = "v0.1.2";
            hash = "sha256-xcQCvl+/d7a3fdqDMEEIyP3c49l1bu7ptCG+RZ94Xws=";
          };

          vendorHash = "sha256-WOzeqHo1cG8USbGUm3OAEUgh3yKTamCaIL3FpsshnjI=";

          subPackages = [ "example" ];
          env.CGO_ENABLED = "0";

          postInstall = ''
            mv $out/bin/example $out/bin/proxy
          '';
        };

        # Assemble the /app directory with all binaries and scripts.
        appDir = pkgs.runCommand "enclave-app" { } ''
          mkdir -p $out/app/data
          cp ${enclave-init}/bin/enclave-init $out/app/enclave-init
          cp ${upstream-app}/bin/${appCfg.binary_name} $out/app/${appCfg.binary_name}
          cp ${nitriding}/bin/nitriding $out/app/nitriding
          cp ${viproxy}/bin/proxy $out/app/proxy
          install -m 0755 ${./enclave/start.sh} $out/app/start.sh
        '';

        # Complete rootfs for the enclave.
        enclaveRootfs = pkgs.buildEnv {
          name = "enclave-rootfs";
          paths = [
            appDir
            pkgs.busybox    # provides /bin/sh and basic utils
            pkgs.cacert     # TLS CA certificates
          ];
          pathsToLink = [ "/" ];
        };

        # Secrets config JSON baked into the EIF for runtime discovery.
        secretsCfgJson = builtins.toJSON (buildCfg.secrets or []);

        # Environment variables for the enclave.
        # Standard vars + all app-specific vars from build-config.json.
        enclaveEnv = let
          appEnvLines = builtins.concatStringsSep "\n"
            (builtins.map (k: "${k}=${builtins.getAttr k appCfg.env}")
              (builtins.attrNames appCfg.env));
        in ''
          PATH=/app:/bin:/usr/bin
          SSL_CERT_FILE=/etc/ssl/certs/ca-bundle.crt
          AWS_REGION=${region}
          ENCLAVE_APP_NAME=${buildCfg.name}
          ENCLAVE_SECRETS_CONFIG=${secretsCfgJson}
          ENCLAVE_DEPLOYMENT=${deployment}
          ${appEnvLines}
        '';

        # Build EIF using monzo/aws-nitro-util (reproducible, no Docker).
        eif = nitro.buildEif {
          name = "${buildCfg.name}-enclave";
          inherit version;

          arch = "x86_64";
          kernel = nitro.blobs.x86_64.kernel;
          kernelConfig = nitro.blobs.x86_64.kernelConfig;
          nsmKo = nitro.blobs.x86_64.nsmKo;

          copyToRoot = enclaveRootfs;
          entrypoint = "/app/start.sh";
          env = enclaveEnv;
        };

      in
      {
        packages = {
          inherit enclave-init upstream-app nitriding viproxy eif;
          default = eif;
        };
      }
    );
}
